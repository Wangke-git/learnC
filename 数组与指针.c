#include<stdio.h>
#include<stdlib.h>
//struct Test
//{
//	int Num;
//	char *pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//};
//此结构体占内存为20个字节
int main()
{
		 //问题1
		 //&a得到是一个int(*)[5],指针数组
		 //&a+1得到的是5后边的那个元素
		 //所以ptr指向的是5后边的那个元素
		 //但是ptr被强转为int*
		 //所以指针-1向前跳过一个元素指向的是5这个元素的地址
		 //在对其*得到5这个元素
		 // *(a+1)可以看成a[1]
		 // 即打印出的就是 2 5
		 //int a[5] = { 1,2,3,4,5 };
		 //int *ptr = (int *)(&a + 1);
		 //printf("%d%d\n", *(a + 1), *(ptr - 1));
		 //问题2
		 // struct Test* p=(struct Test*)0x100000;
		//给P赋值为0x100000
		//%p为打印地址
		//因为p占内存为20
		//所以输出0x100020
		// printf("%p\n",p+0x1);
		//下面的强制类型转换.导致p就变成了一个unsigned long 类型的,在去+1,就只是简单的整数+1,所以输出结果为0x100001
		// printf("%p\n",(unsigned long)p+0x1);
		//此时强转为一个指针类型,指针类型在32位系统下占4个字节所以 输出结果为0x100004
		//指针+1时,需要查看前边类型在内存中需要占几个字节,
		// printf("%p\n",(unsigned int*)p+0x1);
		//问题3
		//int a[4] = { 1,2,3,4 };
		//// &a可以看成int(*)[4],&a+1即跳过整个数组,此时指向4元素后的一位元素
		//int* ptr1 = (int *)(&a + 1);
		////(int)a将a强转为int类型,此时a+1即a[0]+1,即为整数+1
		////a[0]为首元素的地址,但是它现在执行的是整数+1,即首元素的地址+1
		////即假设a[0]的首地址为0x100,但是整个首元素地址为4个字节
		////即0x100-0x103,此时+1位0x101,ptr2指向的就是0x101这个地址
		////*ptr2的含义就是从ptr2存的地址来时往后读取四个字节,即当成一个整数来理解
		////*ptr2它存的就是这四个字节中的整数
		//此电脑为小端字节序
		////a[0]为01 00 00 00a[1]为02 00 00 00
		////即从01后的00开始到02结束,又因为是小端字节序,所以结果为0x02000000
		//int* ptr2 = (int *)((int)a + 1);
		//printf("%x,%x", ptr1[-1], *ptr2);    //输出4 200000
	//问题四
	//注意这里的(),(,)这个表达式为逗号表达式,它只取,最后一位
	//即二维数组的真正的值为{(1,3),{5,0},{0,0}}
	//int a[3][2] = { (0,1),(2,3),(4,5) };
	//int *p;
	////a[0]取到的是一个长度为2的一维数组
	////p是当前这个数组首元素的地址
	//p = a[0];
	////所以输出的应该是1``
	//printf("%d", a[0][0]);
	//return 0;
	//问题5
	//int a[5][5];//二维数组
	//int(*p)[4];//数组指针
	//p = a;
	//printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
	//return 0;
	//问题6
	//	int aa[2][5]=
	//	{
	//		{1,2,3,4,5},
	//	    {6,7,8,9,10}
	//	};
	//	//&aa可以看成将a[2][5]隐式转为int(*)[2][5]
	//	//此时+1可以看成跳过整个数组
	//	//此时ptr1中存的地址应该是10后边元素的地址
	//	//在对ptr1-1在解引用正好是10
	//	int *ptr1 = (int *)(&aa + 1);
	//	//aa[1]可以看成*(aa + 1);
	//	//aa是数组名再+1隐式转为int(*)[5]
	//	//执行+1操作,跳过一个一维数组,即指向5后边的元素
	//	int *ptr2 = (int *)(aa[1]);
	//	//10 5
	//	printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));
	////问题7
	//char* a[] = { "work","at","alibaba" };
	//char**pa = a;
	//pa++;
	//printf("%s\n", *pa);
	//问题8
	char* c[] = { "ENTER","NEW","POINT","FIRST" };
	char** cp[] = { c + 3,c + 2,c + 1,c };
	char*** cpp = cp;
	printf("%s\n", **++cpp);
	printf("%s\n",*--*++cpp+3);
	printf("%s\n", *cpp[-2]+3);
	printf("%s\n", cpp[-1][-1]+1);
}
